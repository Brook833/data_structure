# 3.8 单链表的插入与删除
## 3.8.1 单链表的插入
单链表第i个数据插入结点的算法思路:
> + 1. 声明一结点p指向链表第一个结点，初始化j从0开始
> + 2. 当j<i时，就遍历链表，让p的指针i向后移动，j累加1
> + 3. 若到链表末尾p为空，则说明第i个元素不存在
> + 4. 若查找成功，创建一个空结点s
> + 5. 将数据元素e赋值给s->data
> + 6. 单链表的插入标准语句 s->next = p->next p->next = s

## 3.8.2 单链表的删除
单链表第i个数据删除结点的算法思路:
> + 1. 声明一结点p指向链表第一个结点，初始化j从0开始
> + 2. 当j<i时，就遍历链表，让p的指针向后移动，j累加1
> + 3. 若到链表末尾p为空，则说明第i个元素不存在
> + 4. 若查找成功，将与删除结点p->next赋给q
> + 5. 单链表的删除标准语句p->next = q->next
> + 6. 将q结点中的数据赋给e
> + 7. 释放q结点

插入和删除算法，都是两部分组成:
> + 遍历找到第i个元素
> + 插入或删除元素

单链表在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。

但如果我们希望从第i个位置，插入10个元素，对于顺序存储结构来说，需要移动n-1个元素，每次都是O(n)。而对于单链表，只需要在第一次时找到第i个指针的位置，此时为O(n)，接下来通过赋值移动指针，时间复杂度为O(1).

显然，对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。