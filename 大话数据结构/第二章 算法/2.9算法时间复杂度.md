# 2.9 算法时间复杂度
## 2.9.1 算法时间复杂度定义
在进行语法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。

算法的时间复杂度，也就是算法的时间量度，记作:==T(n) = O(f(n))。==

他表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。

一般情况下，随着n的增大，T(n)增长最慢的算法为最优解法。

O(1)叫常数阶，O(n)叫线性阶，O(n2)叫平方阶。

## 2.9.2 推导大O阶方法
推导大O阶方法:
> + 1.用常数1取代运行时间中的所有加法常数
> + 2.在修改后的运行次数函数中，只保留最高项阶
> + 3.如果最高项阶存在且不是1，则去除与这个项相乘的常数
> 得到的就是大O阶

## 2.9.3 常数阶
```c++
int sum = 0, n = 100;   // 执行一次
sum = (n + 1) * n / 2;  // 执行一次
cout << sum << endl;    // 执行一次
```

这个算法的运行次数函数是f(n) = 3。

第一步把常数项3改为1。在保留最高阶项时发现，他没有最高阶项，所有时间复杂度为O(1)。

对于分支结构而言，无论是真假，执行的次数都是恒定的，单纯的分支结构(不包含在循环结构中)，其时间复杂度也是O(1)。

## 2.9.4 线性阶
O(n);
```c++
int i;
for (i = 0; i < n; i++) {
    /*时间复杂度为O(1)的程序步骤序列*/
}
```

## 2.9.5 对数阶
```c++
int count = i;
while (count < n) {
    count = count * 2;
    /*时间复杂度为O(1)的程序步骤序列*/
}
```

由于每次count乘2之后，就距离n更近了。也就是说2的x次方 = n，得到x = log2 n。所以这个循环的时间复杂度为O(logn);

## 2.9.6 平方阶
```c++
int i, j;
for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
        /*时间复杂度为O(1)的程序步骤序列*/
    }
}
```

对于外层的循环，不过是内部这个时间复杂度为O(n)的语句，在循环n此。所以这段代码的时间复杂度为O(n2);

即使外层循环为m次，时间复杂度也为O(n2);